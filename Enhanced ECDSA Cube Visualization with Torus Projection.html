<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ECDSA Cube Visualization (u_r, u_z, d) | AuditCore v3.2</title>
    <script src="https://cdn.plot.ly/plotly-2.28.0.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: #121212;
            color: #e0e0e0;
            overflow-x: hidden;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            margin-bottom: 20px;
            padding: 20px 0;
        }
        
        h1 {
            font-size: 2.2rem;
            margin-bottom: 10px;
            background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .subtitle {
            font-size: 1.1rem;
            color: #a0a0a0;
            max-width: 800px;
            margin: 0 auto;
        }
        
        .content {
            display: flex;
            gap: 20px;
            height: 80vh;
        }
        
        .controls {
            width: 300px;
            background: #1e1e1e;
            border-radius: 10px;
            padding: 20px;
            overflow-y: auto;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .visualization {
            flex: 1;
            background: #1e1e1e;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        #ecdsa-cube {
            width: 100%;
            height: 100%;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            color: #e0e0e0;
            font-weight: 500;
        }
        
        .slider {
            width: 100%;
            margin-bottom: 15px;
        }
        
        .btn {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: #121212;
            border: none;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            width: 100%;
            transition: all 0.3s ease;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(79, 172, 254, 0.4);
        }
        
        .info-panel {
            background: #1e1e1e;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .info-title {
            font-size: 1.3rem;
            margin-bottom: 15px;
            color: #4facfe;
        }
        
        .info-content {
            line-height: 1.6;
            color: #c0c0c0;
        }
        
        .highlight {
            color: #00f2fe;
            font-weight: 500;
        }
        
        .tabs {
            display: flex;
            margin-bottom: 15px;
            border-bottom: 1px solid #333;
        }
        
        .tab {
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.3s ease;
        }
        
        .tab.active {
            border-bottom: 2px solid #00f2fe;
            color: #00f2fe;
        }
        
        .explanation {
            background: #252525;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
        }
        
        .math-formula {
            background: #2a2a2a;
            padding: 12px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
            overflow-x: auto;
        }
        
        @media (max-width: 1100px) {
            .content {
                flex-direction: column;
                height: auto;
            }
            
            .controls, .visualization {
                width: 100%;
                height: 500px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ECDSA Cube Visualization (u<sub>r</sub>, u<sub>z</sub>, d)</h1>
            <p class="subtitle">Interactive demonstration of spiral structures and mirror pairs in ECDSA space (visual aid)</p>
        </header>
        
        <div class="content">
            <div class="controls">
                <div class="control-group">
                    <div class="control-label">
                        <span>Cube size</span>
                        <span id="cube-size-value">9×9×8</span>
                    </div>
                    <input type="range" min="5" max="15" value="9" class="slider" id="cube-size">
                </div>
                
                <div class="control-group">
                    <div class="control-label">
                        <span>Display value</span>
                        <span id="rx-value">All</span>
                    </div>
                    <input type="range" min="-1" max="8" value="-1" class="slider" id="rx-selector">
                    <div style="display: flex; justify-content: space-between; font-size: 0.8rem; color: #888; margin-top: 5px;">
                        <span>All</span>
                        <span>0-8</span>
                    </div>
                </div>

                <div class="control-group">
                    <div class="control-label">
                        <span>Value mode</span>
                    </div>
                    <select id="value-mode" class="slider" style="padding: 6px; border-radius: 6px; background: #2a2a2a; color: #e0e0e0; border: 1px solid #333;">
                        <option value="rx" selected>R_x (symmetric)</option>
                        <option value="k">k (raw)</option>
                        <option value="real">r = x(kG) (toy curve)</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <div class="control-label">
                        <span>Private key d</span>
                        <span id="d-value">5</span>
                    </div>
                    <input type="range" min="1" max="8" value="5" class="slider" id="d-selector">
                </div>
                
                <div class="control-group">
                    <div class="tabs">
                        <div class="tab active" data-view="spiral">Spiral Structures</div>
                        <div class="tab" data-view="torus">Torus Projection</div>
                        <div class="tab" data-view="layers">Layers by d</div>
                    </div>
                </div>
                
                <div class="control-group">
                    <button class="btn" id="reset-view">Reset View</button>
                </div>
                
                <div class="control-group">
                    <div class="control-label">
                        <span>Mirror Pairs</span>
                    </div>
                    <div class="explanation">
                        <p>Symmetric mode: <span id="mirror-pairs">2 per value</span></p>
                        <p>Topology: β₀=1, β₁=<span id="betti-1">2</span>, β₂=1</p>
                    </div>
                </div>
                
                <div class="control-group">
                    <div class="control-label">
                        <span>Compression ratio</span>
                        <span>Demo</span>
                    </div>
                    <div class="explanation">
                        <p>Placeholder values for UI layout</p>
                        <p>No measurement in this demo</p>
                    </div>
                </div>
            </div>
            
            <div class="visualization">
                <div id="ecdsa-cube"></div>
            </div>
        </div>
        
        <div class="info-panel">
            <h2 class="info-title">Explanation of Visualization</h2>
            <div class="info-content">
                <p>This visualization shows a discrete <span class="highlight">3D hypercube</span> of (u<sub>r</sub>, u<sub>z</sub>, d) derived from the relation:</p>

                <div class="math-formula">
                    k = (u_r·d + u_z) mod n
                </div>

                <p>It is a visual aid for structural patterns only and does not constitute a cryptographic audit.</p>

                <div class="explanation">
                    <p><strong>Value modes:</strong></p>
                    <p><strong>R<sub>x</sub> (symmetric):</strong> displays <em>min(k, n-k)</em> to emphasize the k ↔ −k pairing. This is a visualization-only transform.</p>
                    <p><strong>k (raw):</strong> displays the direct k value with no symmetry enforcement.</p>
                    <p><strong>r = x(kG) (toy curve):</strong> uses the toy curve y² = x³ + 2x + 3 (mod 97) with base point G=(3,6), then sets r = x(kG) mod n. This is not secp256k1.</p>
                </div>

                <div class="explanation">
                    <p><strong>Mirror pairs (symmetric mode):</strong> k and −k map to the same displayed value. For fixed u<sub>r</sub>, paired u<sub>z</sub> values satisfy:</p>
                    
                    <div class="math-formula">
                        u_z + u_z' ≡ -2·u_r·d (mod n)
                    </div>
                    
                    <p>Special cases: k = 0 and, if n is even, k = n/2 are unpaired.</p>
                </div>
                
                <div class="explanation">
                    <p><strong>Example (d=5, n=9):</strong></p>
                    
                    <div class="math-formula">
                        For u_r = 2, choose k = 3:<br>
                        u_z = (k - u_r·d) mod 9 = (3 - 10) mod 9 = 2<br>
                        u_z' = (-2·u_r·d - u_z) mod 9 = (-20 - 2) mod 9 = 5
                    </div>
                    
                    <p>Points (2,2) and (2,5) are a mirror pair in symmetric mode.</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let cubeSize = 9;
        let selectedRx = -1; // -1 means "all"
        let selectedD = 5;
        let currentView = 'spiral';
        let valueMode = 'rx'; // rx | k | real
        
        // Initialize on load
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize sliders
            initSliders();
            
            // Initialize tabs
            initTabs();
            
            // Build initial visualization
            buildVisualization();
            
            // Event handlers
            document.getElementById('reset-view').addEventListener('click', resetView);
        });
        
        function initSliders() {
            const cubeSizeSlider = document.getElementById('cube-size');
            const rxSelector = document.getElementById('rx-selector');
            const dSelector = document.getElementById('d-selector');
            const valueModeSelect = document.getElementById('value-mode');
            
            // Set max value for dSelector based on cube size
            dSelector.min = 1;
            dSelector.max = Math.max(1, cubeSize - 1);
            dSelector.value = Math.min(Math.max(selectedD, 1), dSelector.max);
            selectedD = parseInt(dSelector.value);
            document.getElementById('d-value').textContent = selectedD;
            
            cubeSizeSlider.addEventListener('input', function() {
                cubeSize = parseInt(this.value);
                document.getElementById('cube-size-value').textContent = `${cubeSize}×${cubeSize}×${cubeSize - 1}`;
                
                // Update dSelector max and value
                dSelector.max = Math.max(1, cubeSize - 1);
                if (selectedD > dSelector.max) {
                    selectedD = dSelector.max;
                }
                if (selectedD < 1) {
                    selectedD = 1;
                }
                dSelector.value = selectedD;
                document.getElementById('d-value').textContent = selectedD;
                
                // Update rxSelector max
                rxSelector.max = cubeSize - 1;
                if (selectedRx > rxSelector.max) {
                    selectedRx = -1;
                    rxSelector.value = -1;
                    document.getElementById('rx-value').textContent = 'All';
                }
                
                buildVisualization();
            });
            
            rxSelector.addEventListener('input', function() {
                selectedRx = parseInt(this.value);
                document.getElementById('rx-value').textContent = selectedRx === -1 ? 'All' : selectedRx;
                buildVisualization();
            });
            
            dSelector.addEventListener('input', function() {
                selectedD = parseInt(this.value);
                document.getElementById('d-value').textContent = selectedD;
                buildVisualization();
            });

            valueModeSelect.addEventListener('change', function() {
                valueMode = this.value;
                buildVisualization();
            });
        }
        
        function initTabs() {
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => {
                tab.addEventListener('click', function() {
                    if (!this.classList.contains('active')) {
                        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                        this.classList.add('active');
                        currentView = this.getAttribute('data-view');
                        buildVisualization();
                    }
                });
            });
        }
        
        function resetView() {
            buildVisualization();
        }
        
        function buildVisualization() {
            // Create data for visualization
            const data = generateCubeData();
            
            // Create layout
            const layout = {
                title: {
                    text: `ECDSA Hypercube: ${cubeSize}×${cubeSize}×${cubeSize - 1} | d = ${selectedD}`,
                    font: {
                        color: '#e0e0e0'
                    }
                },
                scene: {
                    xaxis: {
                        title: 'u<sub>r</sub>',
                        range: [0, cubeSize-1],
                        gridcolor: 'rgba(100, 100, 100, 0.5)',
                        zerolinecolor: 'rgba(150, 150, 150, 0.5)',
                        showbackground: true,
                        backgroundcolor: 'rgba(30, 30, 30, 0.5)'
                    },
                    yaxis: {
                        title: 'u<sub>z</sub>',
                        range: [0, cubeSize-1],
                        gridcolor: 'rgba(100, 100, 100, 0.5)',
                        zerolinecolor: 'rgba(150, 150, 150, 0.5)',
                        showbackground: true,
                        backgroundcolor: 'rgba(30, 30, 30, 0.5)'
                    },
                    zaxis: {
                        title: 'd',
                        range: [1, cubeSize - 1],
                        gridcolor: 'rgba(100, 100, 100, 0.5)',
                        zerolinecolor: 'rgba(150, 150, 150, 0.5)',
                        showbackground: true,
                        backgroundcolor: 'rgba(30, 30, 30, 0.5)'
                    },
                    aspectmode: 'cube',
                    camera: {
                        up: {x: 0, y: 0, z: 1},
                        center: {x: 0, y: 0, z: 0},
                        eye: {x: 1.25, y: 1.25, z: 1.25}
                    }
                },
                margin: {
                    l: 0,
                    r: 0,
                    b: 0,
                    t: 40
                },
                paper_bgcolor: '#1e1e1e',
                plot_bgcolor: '#1e1e1e',
                font: {
                    color: '#e0e0e0'
                }
            };
            
            // Create plot
            Plotly.newPlot('ecdsa-cube', data, layout, {responsive: true});
            
            // Update topology info
            updateTopologyInfo();
        }
        
        function createTorus() {
            const R = 1.5; // Major radius
            const r = 0.7; // Minor radius
            const n = 50; // Resolution
            
            const x = [];
            const y = [];
            const z = [];
            
            // Create torus mesh
            for (let i = 0; i <= n; i++) {
                const theta = (i / n) * 2 * Math.PI;
                for (let j = 0; j <= n; j++) {
                    const phi = (j / n) * 2 * Math.PI;
                    
                    x.push((R + r * Math.cos(theta)) * Math.cos(phi));
                    y.push((R + r * Math.cos(theta)) * Math.sin(phi));
                    z.push(r * Math.sin(theta));
                }
            }
            
            // Center the torus in the middle of the cube
            const center = (cubeSize - 1) / 2;
            const centeredX = x.map(val => val + center);
            const centeredY = y.map(val => val + center);
            const centeredZ = z.map(val => val + center);
            
            return {
                x: centeredX,
                y: centeredY,
                z: centeredZ,
                type: 'surface',
                colorscale: [[0, 'rgba(79, 172, 254, 0.05)'], [1, 'rgba(0, 242, 254, 0.05)']],
                showscale: false,
                opacity: 0.15,
                name: 'Torus',
                lighting: {
                    ambient: 0.8,
                    diffuse: 0.8,
                    fresnel: 0.2,
                    specular: 0.2,
                    roughness: 0.5
                },
                lightposition: {
                    x: 100,
                    y: 200,
                    z: 0
                }
            };
        }
        
        function projectToTorus(u_r, u_z, d, n) {
            const R = 1.5; // Major radius
            const r = 0.7; // Minor radius
            
            // Normalize coordinates to [0, 1] range
            const u_r_norm = u_r / (n - 1);
            const u_z_norm = u_z / (n - 1);
            
            // Calculate torus coordinates
            const theta = 2 * Math.PI * u_r_norm;
            const phi = 2 * Math.PI * u_z_norm;
            
            // Center the torus in the middle of the cube
            const center = (n - 1) / 2;
            const x = center + (R + r * Math.cos(theta)) * Math.cos(phi);
            const y = center + (R + r * Math.cos(theta)) * Math.sin(phi);
            const z = center + r * Math.sin(theta);
            
            return [x, y, z];
        }

        const toyCurve = {
            p: 97,
            a: 2,
            b: 3,
            G: { x: 3, y: 6 }
        };

        function mod(a, p) {
            const res = a % p;
            return res < 0 ? res + p : res;
        }

        function modInv(a, p) {
            let t = 0;
            let newT = 1;
            let r = p;
            let newR = mod(a, p);

            while (newR !== 0) {
                const q = Math.floor(r / newR);
                [t, newT] = [newT, t - q * newT];
                [r, newR] = [newR, r - q * newR];
            }

            if (r > 1) return null;
            if (t < 0) t += p;
            return t;
        }

        function pointAdd(P, Q) {
            const p = toyCurve.p;
            const a = toyCurve.a;

            if (!P) return Q;
            if (!Q) return P;

            if (P.x === Q.x && mod(P.y + Q.y, p) === 0) {
                return null;
            }

            let m;
            if (P.x === Q.x && P.y === Q.y) {
                const denom = modInv(2 * P.y, p);
                if (denom === null) return null;
                m = mod((3 * P.x * P.x + a) * denom, p);
            } else {
                const denom = modInv(Q.x - P.x, p);
                if (denom === null) return null;
                m = mod((Q.y - P.y) * denom, p);
            }

            const rx = mod(m * m - P.x - Q.x, p);
            const ry = mod(m * (P.x - rx) - P.y, p);
            return { x: rx, y: ry };
        }

        function scalarMul(k, P) {
            let result = null;
            let addend = P;
            let n = k;

            while (n > 0) {
                if (n & 1) {
                    result = pointAdd(result, addend);
                }
                addend = pointAdd(addend, addend);
                n >>= 1;
            }

            return result;
        }
        
        function generateCubeData() {
            const n = cubeSize;
            const data = [];
            const valueLabel = valueMode === 'k' ? 'k' : (valueMode === 'real' ? 'r' : 'R_x');
            
            // Create grid
            const u_r = Array.from({length: n}, (_, i) => i);
            const u_z = Array.from({length: n}, (_, i) => i);
            const d_vals = Array.from({length: n - 1}, (_, i) => i + 1); // d in [1, n-1]
            
            // Calculate displayed value for each point using the selected mode
            // k = (u_r * d + u_z) mod n
            const valueTable = [];
            
            for (let d_idx = 0; d_idx < d_vals.length; d_idx++) {
                const d = d_vals[d_idx];
                const layer = [];
                
                for (let u_r_i = 0; u_r_i < n; u_r_i++) {
                    const row = [];
                    
                    for (let u_z_i = 0; u_z_i < n; u_z_i++) {
                        // Calculate k using the correct formula
                        let k = (u_r_i * d + u_z_i) % n;
                        
                        // Ensure k is non-negative
                        if (k < 0) k += n;
                        
                        let value;
                        if (valueMode === 'k') {
                            value = k;
                        } else if (valueMode === 'real') {
                            const point = scalarMul(k, toyCurve.G);
                            const r = point ? point.x : 0;
                            value = r % n;
                        } else {
                            // Symmetric visualization: min(k, n-k)
                            let sym = Math.min(k, n - k);
                            if (k === 0 || (n % 2 === 0 && k === n / 2)) {
                                sym = k;
                            }
                            value = sym;
                        }
                        
                        row.push(value);
                    }
                    layer.push(row);
                }
                valueTable.push(layer);
            }
            
            if (currentView === 'spiral') {
                // Spiral structures
                for (let r_val = 0; r_val < n; r_val++) {
                    if (selectedRx !== -1 && selectedRx !== r_val) continue;
                    
                    const x = [];
                    const y = [];
                    const z = [];
                    
                    for (let d_idx = 0; d_idx < d_vals.length; d_idx++) {
                        const d = d_vals[d_idx];
                        for (let u_r_i = 0; u_r_i < n; u_r_i++) {
                            // Find u_z where value = r_val
                            for (let u_z_i = 0; u_z_i < n; u_z_i++) {
                                if (valueTable[d_idx][u_r_i][u_z_i] === r_val) {
                                    x.push(u_r_i);
                                    y.push(u_z_i);
                                    z.push(d);
                                }
                            }
                        }
                    }
                    
                    if (x.length > 0) {
                        data.push({
                            x: x,
                            y: y,
                            z: z,
                            type: 'scatter3d',
                            mode: 'lines+markers',
                            marker: {
                                size: 4,
                                color: r_val / n,
                                colorscale: 'Viridis',
                                opacity: 0.8
                            },
                            line: {
                                width: 3,
                                color: `hsl(${r_val * 40}, 70%, 50%)`
                            },
                            name: `${valueLabel} = ${r_val}`,
                            hovertemplate: 'u_r: %{x}<br>u_z: %{y}<br>d: %{z}<br>' + valueLabel + ': ' + r_val + '<extra></extra>'
                        });
                    }
                }
            } 
            else if (currentView === 'torus') {
                // Add semi-transparent torus in the center
                data.push(createTorus());
                
                // Add projections from the cube points onto the torus
                for (let r_val = 0; r_val < n; r_val++) {
                    if (selectedRx !== -1 && selectedRx !== r_val) continue;
                    
                    const x = [];
                    const y = [];
                    const z = [];
                    const customdata = [];
                    
                    for (let d_idx = 0; d_idx < d_vals.length; d_idx++) {
                        const d = d_vals[d_idx];
                        for (let u_r_i = 0; u_r_i < n; u_r_i++) {
                            for (let u_z_i = 0; u_z_i < n; u_z_i++) {
                                if (valueTable[d_idx][u_r_i][u_z_i] === r_val) {
                                    // Project point onto the torus
                                    const [tx, ty, tz] = projectToTorus(u_r_i, u_z_i, d, n);
                                    x.push(tx);
                                    y.push(ty);
                                    z.push(tz);
                                    customdata.push([u_r_i, u_z_i, d]);
                                }
                            }
                        }
                    }
                    
                    if (x.length > 0) {
                        data.push({
                            x: x,
                            y: y,
                            z: z,
                            type: 'scatter3d',
                            mode: 'markers',
                            marker: {
                                size: 5,
                                color: `hsl(${r_val * 40}, 70%, 50%)`,
                                opacity: 0.9
                            },
                            name: `${valueLabel} = ${r_val} (projection)`,
                            hovertemplate: 'u_r: %{customdata[0]}<br>u_z: %{customdata[1]}<br>d: %{customdata[2]}<br>' + valueLabel + ': ' + r_val + '<extra></extra>',
                            customdata: customdata
                        });
                    }
                }
                
                // Add the original cube points with low opacity for context
                const cubeX = [];
                const cubeY = [];
                const cubeZ = [];
                const cubeColors = [];
                
                for (let d_idx = 0; d_idx < d_vals.length; d_idx++) {
                    const d = d_vals[d_idx];
                    for (let u_r_i = 0; u_r_i < n; u_r_i++) {
                        for (let u_z_i = 0; u_z_i < n; u_z_i++) {
                            cubeX.push(u_r_i);
                            cubeY.push(u_z_i);
                            cubeZ.push(d);
                            cubeColors.push(valueTable[d_idx][u_r_i][u_z_i]);
                        }
                    }
                }
                
                data.push({
                    x: cubeX,
                    y: cubeY,
                    z: cubeZ,
                    type: 'scatter3d',
                    mode: 'markers',
                    marker: {
                        size: 2,
                        color: cubeColors,
                        colorscale: 'Viridis',
                        opacity: 0.05
                    },
                    name: 'Original Cube',
                    hoverinfo: 'none'
                });
            }
            else if (currentView === 'layers') {
                // Layers by d
                for (let d_idx = 0; d_idx < d_vals.length; d_idx++) {
                    const d = d_vals[d_idx];
                    if (d !== selectedD) continue;
                    
                    const x = [];
                    const y = [];
                    const z = [];
                    const colors = [];
                    
                    for (let u_r_i = 0; u_r_i < n; u_r_i++) {
                        for (let u_z_i = 0; u_z_i < n; u_z_i++) {
                            x.push(u_r_i);
                            y.push(u_z_i);
                            z.push(d);
                            colors.push(valueTable[d_idx][u_r_i][u_z_i]);
                        }
                    }
                    
                    data.push({
                        x: x,
                        y: y,
                        z: z,
                        type: 'scatter3d',
                        mode: 'markers',
                        marker: {
                            size: 6,
                            color: colors,
                            colorscale: 'Viridis',
                            opacity: 0.9
                        },
                        name: `d = ${d}`,
                        hovertemplate: 'u_r: %{x}<br>u_z: %{y}<br>' + valueLabel + ': %{marker.color}<extra></extra>'
                    });
                }
            }
            
            return data;
        }
        
        function updateTopologyInfo() {
            // In a real system, this data would come from analysis
            const betti1 = 2.0;
            const mirrorText = valueMode === 'rx'
                ? '2 per value (except 0 and n/2)'
                : 'N/A (non-symmetric mode)';
            
            document.getElementById('mirror-pairs').textContent = mirrorText;
            document.getElementById('betti-1').textContent = betti1;
        }
    </script>
</body>
</html>
